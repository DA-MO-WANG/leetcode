//
// Created by rich heart on 5/7/22.
//
#include <algorithm>
#include <cstdio>
#include <iostream>
//并查集维护额外信息
//本质：递归法则感悟+数学归纳法法则感悟
//维护食物链之间的关系集合：一共有三种关系，类似闭环贪吃蛇结构--代际关系
//！！！三种关系依赖一种规则：每个节点到根节点的距离对3的取模-按照题意抽象出的食物规则
    //余为0，代表与根节点同类---食物关系等同
    //余为1，代表吃根节点
    //余为2，代表吃-吃根节点的节点-的节点，也是被根节点吃的节点
//如何维护每个节点到根节点的距离？(数学归纳法的本质)
    //d[x] 最开始只能维护当前节点到父节点的距离（直接相连的节点的距离）-初始值是0
    //随着路径压缩，在递归的过程中， œ完成了每个节点到根节点距离的计算
    //先递归find(p[x]) 这个过程一完成，d[p[x]]也完成了，p[x]这个点到根节点的距离计算（预估完成的）
    //计算当前节点到根节点的距离：d[x] = d[x]（x-x父） + d[p[x]]（x父-根）
    //更新当前节点的父节点 p[x] = 保存的根节点位置

//题意：找假话
//先找出是假话的条件，满足这个条件就记录假话数量：
    //相关的已知语料构成了相关关系集合，只要同属一个关系集合内，就能明确真假
    //不在同一个关系集合下的，也就不能是假，也就往真里去变，继续补充这个关系集合
    //如何判断是否在关系集合内，就得需要看根节点是否是同一个
//不满足假话的条件，不能证明是假，就可以当作既成事实来继续构建，朝着真的方向来构建

using namespace std;
const int N = 50010;
int f[N], hg[N];
int find(int x) {
    if(f[x] != x) {
        int t = find(f[x]);
        hg[x] += hg[f[x]];
        f[x] = t;
    }
    return f[x];
}
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        f[i] = i;
    }
    int k;
    cin >> k;
    int res = 0;
    int d,x,y;
    while (k--) {
        cin >> d >> x >>y;
        if(x > n || y > n) ++res;
        else {
            int zx = find(x), zy = find(y);
            if (d == 1) {
                if(zx == zy) {
                    if((hg[x] - hg[y])%3)  ++res;
                }else {
                    //不在一个集合内，不能证明是假的，就可以当作是真得，也就认可xy同类，暂且让x指y-也就明确了x,y的集合变化
                    //为了构造他俩同类，就得hg[x] + ? = hg[y] ==> ? = hg[y] - hg[x]
                    f[zx] = zy;
                    hg[zx] = hg[y] - hg[x];
                }

            }else {
                if(d == 2) {
                    if(zx == zy) {
                        if(hg[x] % 3 - hg[y] %3 - 1) ++res;
                    }else {
                        f[zx] = zy;
                        hg[zx] = hg[y] + 1 - hg[x];
                    }
                }
            }
        }

    }
    cout << res;
}
