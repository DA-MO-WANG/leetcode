package array;

import java.util.HashSet;

public class leetcode3 {
    //寻找字符串中的最大不重复子串
    //审题：子串--必然是连续的；如何确定一个字串：只需要确定两个端点
    //子功能：如何判断是否具有重复的东西

    //业务理解
    //我们如何找到所有字串？--界定两个端点下标--也是字符串的下标，先定下左指针，左边从0开始，右边从-1开始
    //先定下左边，右边依次遍历，如果不关心是否具有重复，那么右边走到末尾都是字串---数学真是一个好东西，区间只需要记录哟个区间符号，两个端点，再加一个本体，就能表示比这多得多多的东西，这大概就是智慧吧
    //然后走完一轮，左边在开始移动，然后再进行一轮——》这样的遍历前后是彼此独立的，独立就意味着不能复用，很多重复功
    //我们只需要再每一次遍历中，做检验是否重复的操作---右指针每一次向右移动，都代表依次新的子串，然后新增加的这个字符去前面记录表中查询是否有，没有就是不重复
    //判断一个字串是否具有重复的，只要在他形成的时候，每多一个就去前面翻一下：化静为动

    //如何维护最大不重复长度？
        //只要前面满足不重复，就往右移动。直到遇到范例--每一轮的标志：左指针定下来，每一个定下来的左指针都对应一个最大字串
        //不止一个左指针，那怎么保存这么多长度呢？---换个角度，每一轮只保存与上一个比较中的最大值--类似字串判断具有重复的道理一样
        //不必保存一堆数据，然后再比较出最大值--而是在一堆数据的产生过程中，就做比较，每次做比较，只留下最大值，那么整个流程下来就会出现最大值---math函数

    public static void main(String[] args) {
      //易错点：在校验是否具有重复的时候：是具体的每一个字串中校验的，也就是记录表要保持上字串的变化--即使踢出左边的变化
    }
}
